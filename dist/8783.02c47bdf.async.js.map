{"version":3,"file":"8783.02c47bdf.async.js","mappings":"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","sources":["webpack:///./node_modules/react-remove-scroll/dist/es2015/medium.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/UI.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/handleScroll.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/SideEffect.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/sidecar.js","webpack:///./node_modules/react-remove-scroll/dist/es2015/Combination.js","webpack:///./node_modules/@radix-ui/react-focus-scope/dist/index.mjs"],"sourcesContent":["import { createSidecarMedium } from 'use-sidecar';\nexport var effectCar = createSidecarMedium();\n","import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { fullWidthClassName, zeroRightClassName } from 'react-remove-scroll-bar/constants';\nimport { useMergeRefs } from 'use-callback-ref';\nimport { effectCar } from './medium';\nvar nothing = function () {\n    return;\n};\n/**\n * Removes scrollbar from the page and contain the scroll within the Lock\n */\nvar RemoveScroll = React.forwardRef(function (props, parentRef) {\n    var ref = React.useRef(null);\n    var _a = React.useState({\n        onScrollCapture: nothing,\n        onWheelCapture: nothing,\n        onTouchMoveCapture: nothing,\n    }), callbacks = _a[0], setCallbacks = _a[1];\n    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, gapMode = props.gapMode, rest = __rest(props, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\", \"gapMode\"]);\n    var SideCar = sideCar;\n    var containerRef = useMergeRefs([ref, parentRef]);\n    var containerProps = __assign(__assign({}, rest), callbacks);\n    return (React.createElement(React.Fragment, null,\n        enabled && (React.createElement(SideCar, { sideCar: effectCar, removeScrollBar: removeScrollBar, shards: shards, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode: gapMode })),\n        forwardProps ? (React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef }))) : (React.createElement(Container, __assign({}, containerProps, { className: className, ref: containerRef }), children))));\n});\nRemoveScroll.defaultProps = {\n    enabled: true,\n    removeScrollBar: true,\n    inert: false,\n};\nRemoveScroll.classNames = {\n    fullWidth: fullWidthClassName,\n    zeroRight: zeroRightClassName,\n};\nexport { RemoveScroll };\n","var passiveSupported = false;\nif (typeof window !== 'undefined') {\n    try {\n        var options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                passiveSupported = true;\n                return true;\n            },\n        });\n        // @ts-ignore\n        window.addEventListener('test', options, options);\n        // @ts-ignore\n        window.removeEventListener('test', options, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n}\nexport var nonPassive = passiveSupported ? { passive: false } : false;\n","var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    if (!(node instanceof Element)) {\n        return false;\n    }\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var ownerDocument = node.ownerDocument;\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];\n            if (scrollHeight > clientHeight) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== ownerDocument.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        if (target instanceof ShadowRoot) {\n            target = target.host;\n        }\n        else {\n            target = target.parentNode;\n        }\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    // handle epsilon around 0 (non standard zoom levels)\n    if (isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScroll) < 1) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScrollTop) < 1) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n","import { __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScrollBar } from 'react-remove-scroll-bar';\nimport { styleSingleton } from 'react-style-singleton';\nimport { nonPassive } from './aggresiveCapture';\nimport { handleScroll, locationCouldBeScrolled } from './handleScroll';\nexport var getTouchXY = function (event) {\n    return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];\n};\nexport var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };\nvar extractRef = function (ref) {\n    return ref && 'current' in ref ? ref.current : ref;\n};\nvar deltaCompare = function (x, y) { return x[0] === y[0] && x[1] === y[1]; };\nvar generateStyle = function (id) { return \"\\n  .block-interactivity-\".concat(id, \" {pointer-events: none;}\\n  .allow-interactivity-\").concat(id, \" {pointer-events: all;}\\n\"); };\nvar idCounter = 0;\nvar lockStack = [];\nexport function RemoveScrollSideCar(props) {\n    var shouldPreventQueue = React.useRef([]);\n    var touchStartRef = React.useRef([0, 0]);\n    var activeAxis = React.useRef();\n    var id = React.useState(idCounter++)[0];\n    var Style = React.useState(styleSingleton)[0];\n    var lastProps = React.useRef(props);\n    React.useEffect(function () {\n        lastProps.current = props;\n    }, [props]);\n    React.useEffect(function () {\n        if (props.inert) {\n            document.body.classList.add(\"block-interactivity-\".concat(id));\n            var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);\n            allow_1.forEach(function (el) { return el.classList.add(\"allow-interactivity-\".concat(id)); });\n            return function () {\n                document.body.classList.remove(\"block-interactivity-\".concat(id));\n                allow_1.forEach(function (el) { return el.classList.remove(\"allow-interactivity-\".concat(id)); });\n            };\n        }\n        return;\n    }, [props.inert, props.lockRef.current, props.shards]);\n    var shouldCancelEvent = React.useCallback(function (event, parent) {\n        if (('touches' in event && event.touches.length === 2) || (event.type === 'wheel' && event.ctrlKey)) {\n            return !lastProps.current.allowPinchZoom;\n        }\n        var touch = getTouchXY(event);\n        var touchStart = touchStartRef.current;\n        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];\n        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];\n        var currentAxis;\n        var target = event.target;\n        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';\n        // allow horizontal touch move on Range inputs. They will not cause any scroll\n        if ('touches' in event && moveDirection === 'h' && target.type === 'range') {\n            return false;\n        }\n        var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n        if (!canBeScrolledInMainDirection) {\n            return true;\n        }\n        if (canBeScrolledInMainDirection) {\n            currentAxis = moveDirection;\n        }\n        else {\n            currentAxis = moveDirection === 'v' ? 'h' : 'v';\n            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n            // other axis might be not scrollable\n        }\n        if (!canBeScrolledInMainDirection) {\n            return false;\n        }\n        if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {\n            activeAxis.current = currentAxis;\n        }\n        if (!currentAxis) {\n            return true;\n        }\n        var cancelingAxis = activeAxis.current || currentAxis;\n        return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);\n    }, []);\n    var shouldPrevent = React.useCallback(function (_event) {\n        var event = _event;\n        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {\n            // not the last active\n            return;\n        }\n        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);\n        var sourceEvent = shouldPreventQueue.current.filter(function (e) { return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta); })[0];\n        // self event, and should be canceled\n        if (sourceEvent && sourceEvent.should) {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            return;\n        }\n        // outside or shard event\n        if (!sourceEvent) {\n            var shardNodes = (lastProps.current.shards || [])\n                .map(extractRef)\n                .filter(Boolean)\n                .filter(function (node) { return node.contains(event.target); });\n            var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;\n            if (shouldStop) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, []);\n    var shouldCancel = React.useCallback(function (name, delta, target, should) {\n        var event = { name: name, delta: delta, target: target, should: should, shadowParent: getOutermostShadowParent(target) };\n        shouldPreventQueue.current.push(event);\n        setTimeout(function () {\n            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });\n        }, 1);\n    }, []);\n    var scrollTouchStart = React.useCallback(function (event) {\n        touchStartRef.current = getTouchXY(event);\n        activeAxis.current = undefined;\n    }, []);\n    var scrollWheel = React.useCallback(function (event) {\n        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    var scrollTouchMove = React.useCallback(function (event) {\n        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    React.useEffect(function () {\n        lockStack.push(Style);\n        props.setCallbacks({\n            onScrollCapture: scrollWheel,\n            onWheelCapture: scrollWheel,\n            onTouchMoveCapture: scrollTouchMove,\n        });\n        document.addEventListener('wheel', shouldPrevent, nonPassive);\n        document.addEventListener('touchmove', shouldPrevent, nonPassive);\n        document.addEventListener('touchstart', scrollTouchStart, nonPassive);\n        return function () {\n            lockStack = lockStack.filter(function (inst) { return inst !== Style; });\n            document.removeEventListener('wheel', shouldPrevent, nonPassive);\n            document.removeEventListener('touchmove', shouldPrevent, nonPassive);\n            document.removeEventListener('touchstart', scrollTouchStart, nonPassive);\n        };\n    }, []);\n    var removeScrollBar = props.removeScrollBar, inert = props.inert;\n    return (React.createElement(React.Fragment, null,\n        inert ? React.createElement(Style, { styles: generateStyle(id) }) : null,\n        removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null));\n}\nfunction getOutermostShadowParent(node) {\n    var shadowParent = null;\n    while (node !== null) {\n        if (node instanceof ShadowRoot) {\n            shadowParent = node.host;\n            node = node.host;\n        }\n        node = node.parentNode;\n    }\n    return shadowParent;\n}\n","import { exportSidecar } from 'use-sidecar';\nimport { RemoveScrollSideCar } from './SideEffect';\nimport { effectCar } from './medium';\nexport default exportSidecar(effectCar, RemoveScrollSideCar);\n","import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScroll } from './UI';\nimport SideCar from './sidecar';\nvar ReactRemoveScroll = React.forwardRef(function (props, ref) { return (React.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: SideCar }))); });\nReactRemoveScroll.classNames = RemoveScroll.classNames;\nexport default ReactRemoveScroll;\n","\"use client\";\n\n// packages/react/focus-scope/src/FocusScope.tsx\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { jsx } from \"react/jsx-runtime\";\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = { bubbles: false, cancelable: true };\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const target = event.target;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleFocusOut2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget;\n        if (relatedTarget === null) return;\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleMutations2 = function(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      };\n      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(\n    (event) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n      const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement;\n      if (isTabKey && focusedElement) {\n        const container2 = event.currentTarget;\n        const [first, last] = getTabbableEdges(container2);\n        const hasTabbableElementsInside = first && last;\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container2) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n  return /* @__PURE__ */ jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\nfunction isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, { select = false } = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\nvar focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter((item) => item.tagName !== \"A\");\n}\nvar Root = FocusScope;\nexport {\n  FocusScope,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["effectCar","nothing","RemoveScroll","props","parentRef","ref","_a","onScrollCapture","onWheelCapture","onTouchMoveCapture","callbacks","setCallbacks","forwardProps","children","className","removeScrollBar","enabled","shards","sideCar","noIsolation","inert","allowPinchZoom","_b","as","Container","gapMode","rest","SideCar","containerRef","useMergeRef","containerProps","lockRef","only","defaultProps","classNames","fullWidth","zeroRight","passiveSupported","window","options","Object","defineProperty","get","addEventListener","removeEventListener","err","nonPassive","passive","elementCanBeScrolled","node","overflow","Element","styles","getComputedStyle","overflowY","overflowX","tagName","alwaysContainsScroll","locationCouldBeScrolled","axis","ownerDocument","current","ShadowRoot","host","elementCouldBeScrolled","getScrollVariables","parentNode","body","elementCouldBeVScrolled","elementCouldBeHScrolled","scrollTop","scrollHeight","clientHeight","scrollLeft","scrollWidth","clientWidth","getHScrollVariables","getTouchXY","event","changedTouches","clientX","clientY","getDeltaXY","deltaX","deltaY","extractRef","generateStyle","id","concat","idCounter","lockStack","getOutermostShadowParent","shadowParent","shouldPreventQueue","touchStartRef","activeAxis","Style","lastProps","document","classList","add","allow_1","map","filter","Boolean","forEach","el","remove","shouldCancelEvent","parent","touches","length","type","ctrlKey","currentAxis","touch","touchStart","target","moveDirection","Math","abs","canBeScrolledInMainDirection","cancelingAxis","endTarget","sourceDelta","noOverscroll","directionFactor","direction","getDirectionFactor","delta","targetInLock","contains","shouldCancelScroll","isDeltaPositive","availableScroll","availableScrollTop","position","elementScroll","handleScroll","shouldPrevent","_event","sourceEvent","e","name","x","y","should","cancelable","preventDefault","shardNodes","shouldCancel","push","setTimeout","scrollTouchStart","undefined","scrollWheel","scrollTouchMove","inst","ReactRemoveScroll","AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","FocusScope","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","lastFocusedElementRef","composedRefs","focusScope","paused","pause","this","resume","handleFocusIn2","focus","select","handleFocusOut2","relatedTarget","handleMutations2","mutations","activeElement","mutation","removedNodes","mutationObserver","MutationObserver","observe","childList","subtree","disconnect","focusScopesStack","previouslyFocusedElement","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","candidates","candidate","focusFirst","items","getTabbableCandidates","item","unmountEvent","handleKeyDown","isTabKey","key","altKey","metaKey","focusedElement","container2","currentTarget","first","last","findVisible","reverse","getTabbableEdges","shiftKey","jsx","div","tabIndex","onKeyDown","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","elements","element","isHidden","upTo","visibility","display","parentElement","preventScroll","HTMLInputElement","isSelectableInput","displayName","stack","activeFocusScope","arrayRemove","unshift","createFocusScopesStack","array","updatedArray","index","indexOf","splice"],"sourceRoot":""}